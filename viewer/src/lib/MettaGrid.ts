const asciiToObjectName = {
  " ": "empty",
  "#": "wall",
  A: "agent",
  C: "converter",
  g: "mine",
  c: "generator",
  a: "altar",
  r: "armory",
  l: "lasery",
  b: "lab",
  f: "factory",
  t: "temple",
  v: "converter",
} as const;

const objectTypes: [ObjectName, string][] = [
  ["agent", "A"], // 0
  ["wall", "#"], // 1
  ["mine", "g"], // 2
  ["generator", "c"], // 3
  ["altar", "a"], // 4
  ["armory", "r"], // 5
  ["lasery", "l"], // 6
  ["lab", "b"], // 7
  ["factory", "f"], // 8
  ["temple", "t"], // 9
  ["converter", "v"], // 10
] as const;

const asciiToTypeId = Object.fromEntries(
  objectTypes.map(([_, ascii], i) => [ascii, i])
);

export type ObjectName =
  (typeof asciiToObjectName)[keyof typeof asciiToObjectName];

export type ItemObjectName = Exclude<ObjectName, "wall" | "agent" | "empty">;

// as generated by mettagrid.pyx
export class MettaObject {
  readonly id: number;
  readonly type: number;
  readonly r: number;
  readonly c: number;
  readonly rawData: unknown;
  constructor(data: {
    id: number;
    type: number;
    r: number;
    c: number;
    rawData: unknown;
    // can contain more fields
  }) {
    this.id = data.id;
    this.type = data.type;
    this.r = data.r;
    this.c = data.c;
    this.rawData = data.rawData;
  }

  get name(): ObjectName {
    return objectTypes[this.type][0];
  }
}

export class MettaGrid {
  private readonly grid: (MettaObject | null)[][];

  constructor(
    private readonly data: {
      width: number;
      height: number;
      objects: MettaObject[];
    }
  ) {
    this.grid = new Array(data.height)
      .fill(null)
      .map(() => new Array(data.width).fill(null));

    for (const object of data.objects) {
      this.grid[object.r][object.c] = object;
    }
  }

  static fromAscii(asciiMap: string) {
    // Parse the data
    const lines = asciiMap.trim().split("\n");
    const width = Math.max(...lines.map((line) => line.length));
    const height = lines.length;
    const objects: MettaObject[] = [];
    lines.forEach((line, y) => {
      line.split("").forEach((char, x) => {
        if (char === " ") {
          return;
        }
        const objectType = asciiToTypeId[char];
        if (objectType === undefined) {
          throw new Error(`Invalid character: '${char}' at ${x},${y}`);
        }
        objects.push(
          new MettaObject({
            id: objects.length,
            type: objectType,
            r: y,
            c: x,
            rawData: undefined, // can't derive from ascii
          })
        );
      });
    });
    return new MettaGrid({ width, height, objects });
  }

  // TODO - make MettaMap data immutable with immutable.js and evolve it by applying objects as a patch
  static fromWebsocketObjects(objects: unknown) {
    // fast parsing; zod is too slow
    if (!objects || typeof objects !== "object") {
      throw new Error("objects is not an object");
    }

    let width = 0,
      height = 0;
    const objectsList: MettaObject[] = [];

    for (const entry of Object.values(objects)) {
      if (!entry || typeof entry !== "object") {
        throw new Error(`objects entry ${entry} is not an object`);
      }
      const id = Number(entry["id"]);
      const type = Number(entry["type"]);
      const r = Number(entry["r"]);
      const c = Number(entry["c"]);
      width = Math.max(width, c);
      height = Math.max(height, r);
      objectsList.push(new MettaObject({ id, type, r, c, rawData: entry }));
    }
    width += 1;
    height += 1;

    return new MettaGrid({ width, height, objects: objectsList });
  }

  object(x: number, y: number): MettaObject | null {
    return this.grid[y][x];
  }

  get width(): number {
    return this.data.width;
  }

  get height(): number {
    return this.data.height;
  }

  get objects(): MettaObject[] {
    return this.data.objects;
  }
}
